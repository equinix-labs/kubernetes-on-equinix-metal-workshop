{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#about-equinix-labs","title":"About Equinix Labs","text":"<p>Equinix Labs offers workshops, proof of concepts, and tools for exploring and bootstrapping Equinix digital infrastructure including Fabric, Metal, and Network Edge.</p>"},{"location":"#about-the-workshop","title":"About the workshop","text":"<p>In this workshop you will learn how to use Terraform to deploy and manage a vanilla Kubernetes cluster on Equinix Metal.</p> <p>The goals of this workshop are:</p> <ul> <li>Become familiar with the Equinix Metal console and tools.</li> <li>Provision Kubernetes using Terraform.</li> <li>Configure kubectl to manage Kubernetes.</li> <li>Deploy an app on a Kubernetes cluster.</li> </ul>"},{"location":"#workshop-agenda","title":"Workshop agenda","text":"<p>This workshop is split into four parts:</p> Part Title Duration 1 Setup 10 minutes 2 Configuration and Provisioning 10 minutes 3 Sample App Deployment 8 minutes 4 Conclusion 2 minutes"},{"location":"parts/conclusion/","title":"Conclusion","text":""},{"location":"parts/conclusion/#conclusion","title":"Conclusion","text":"<p>Thank you for participating in the workshop! Let's recap some of the key takeaways that we've learned:</p> <ul> <li>How to customize a Kubernetes deployment using a Terraform module.</li> <li>Deploy a Kubernetes cluster with Terraform.</li> <li>How to configure a CLI tool to manage a Kubernetes cluster.</li> <li>How to deploy an application on a Kubernetes cluster.</li> </ul>"},{"location":"parts/conclusion/#next-steps","title":"Next Steps","text":"<ul> <li>Deploy other applications on the Kubernetes cluster deployed in this workshop.</li> <li>Learn how to use <code>helm</code> to manage Kubernetes applications.</li> </ul>"},{"location":"parts/conclusion/#resources","title":"Resources","text":"<p>Here are a few other resources to look at to continue your Equinix Metal journey:</p> <ul> <li>Deploy @ Equinix: A one-stop shop for blogs, guides, and plenty of other resources.</li> <li>Equinix Metal Docs: Equinix Metal official documentation.</li> <li>Equinix Metal APIs: Programmatically interact with Equinix Metal</li> <li>Equinix Labs: Provides SDKs and Terraform modultes for Infrastructure as Code tools.</li> <li>Equinix Community: A global community for customers and Equinix users.</li> </ul>"},{"location":"parts/part1/","title":"Part 1: Account and API Key Setup","text":"<p>To run this workshop you will need access to an Equinix Metal Account or create a new one following step 1 below.</p> <p>Note:  You are responsible for the cost of resources created in your Equinix Metal account while running this workshop.</p>"},{"location":"parts/part1/#pre-requisites","title":"Pre-requisites","text":"<p>The following tools will be needed on your local development environment where you will be running most of the commands in this guide:</p> <ul> <li>A Unix-like environment (Linux, OSX, Windows WSL)</li> <li>git (v2.0.0+)</li> <li>metal-cli (v0.9.0+)</li> <li>terraform (v1.0.0+)</li> </ul>"},{"location":"parts/part1/#steps","title":"Steps","text":""},{"location":"parts/part1/#1-create-an-equinix-metal-account","title":"1. Create an Equinix Metal account","text":"<p>If you have never used Equinix Metal before, don't worry, you just need 2 minutes to sign-up and create your first organization. If you have any doubt you can watch our Getting Started with Equinix Metal video.</p>"},{"location":"parts/part1/#2-create-an-api-key","title":"2. Create an API key","text":"<p>API keys in Metal can be tied to your user or to a single project. For this workshop we will need a user-level API key.</p> <p>Note: Project API keys do not have access to the entirety of the API; some endpoints can only be used by personal API keys.</p> <p>To create a new user API key, access your user Profile in the Equinix Metal console, click on the User Icon, and click My Profile.</p> <p></p> <ul> <li>Select the <code>API Keys</code> tab.</li> <li>Click on <code>+ Add New Key</code>.</li> <li>Create a new key with <code>Read/Write</code> permissions.</li> </ul> <p></p>"},{"location":"parts/part1/#3-install-and-configure-metal-cli","title":"3. Install and Configure Metal CLI","text":"<p>Once you are familiar with the console you may feel more comfortable managing your Equinix Metal resources with the command-line interface tool Metal-cli.</p> <p>You only need to download a binary to start enjoying Metal-cli, but you may want to check out the different installation options.</p> <p>Once installed you need to configure your credentials. To do this, execute <code>metal init</code> and provide the requested information.</p> <p>Expected output:</p> Bash<pre><code>$ metal init\n\nEquinix Metal API Tokens can be obtained through the portal at https://console.equinix.com/.\nSee https://metal.equinix.com/developers/docs/accounts/users/ for more details.\n\nToken (hidden): \nOrganization ID [e83e4455-e7bf-4a2f-95cf-653b56db1939]: \nProject ID []: \n\nWriting /Users/Username/.config/equinix/metal.yaml\n</code></pre>"},{"location":"parts/part1/#5-install-git-and-terraform","title":"5. Install Git and Terraform","text":"<p>There are many ways to install <code>git</code> and <code>terraform</code> locally. However, we will use a package manager, <code>homebrew</code>, as an example.</p> Bash<pre><code>$ brew install git\n</code></pre> Bash<pre><code>$ brew install terraform\n</code></pre>"},{"location":"parts/part1/#4-verify","title":"4. Verify","text":"Bash<pre><code>$ metal organization get\n\n+--------------------------------------+------------------------------+----------------------+\n|                  ID                  |             NAME             |       CREATED        |\n+--------------------------------------+------------------------------+----------------------+\n| e83e4455-e7bf-4a2f-95cf-653b56db1939 | Equinix Metal Kubernetes POC | 2023-01-01T00:00:00Z |\n+--------------------------------------+------------------------------+----------------------+\n\n$ git -v\ngit version 2.40.0\n\n$ terraform -v\nTerraform v1.5.6\non darwin_arm64\n</code></pre>"},{"location":"parts/part1/#discussion","title":"Discussion","text":"<p>Before proceeding to the next part let's take a few minutes to discuss what we did. Here are some questions to start the discussion.</p> <ul> <li>Can we create API keys without manually using the portal?</li> </ul>"},{"location":"parts/part2/","title":"2. Kubernetes Deployment and Configuration","text":""},{"location":"parts/part2/#part-2-kubernetes-deployment-and-configuration","title":"Part 2: Kubernetes Deployment and Configuration","text":"<p>The following steps require that you be familiar with HashiCorp Terraform modules. For more info, please read Terraform's documentation. The steps below will guide you to deploy Kubernetes with a Terraform module in an automated fashion.</p>"},{"location":"parts/part2/#steps","title":"Steps","text":""},{"location":"parts/part2/#1-clone-the-terraform-equinix-kubernetes-cluster-repo","title":"1. Clone the terraform-equinix-kubernetes-cluster repo","text":"<p>For this workshop, we will clone the repository <code>terraform-equinix-kubernetes-cluster</code>, to provision a kubernetes cluster. This repository contains a Terraform module that you will run to provision the cluster.</p> Bash<pre><code>$ git clone https://github.com/equinix-labs/terraform-equinix-kubernetes-cluster.git\n$ cd terraform-equinix-kubernetes-cluster\n</code></pre>"},{"location":"parts/part2/#2-customize-the-terraform-deployment","title":"2. Customize the Terraform Deployment","text":"<p>Now that we have cloned the kubernetes repo, we will need to customize our deployment. Let's first create a subfolder for our custom deployment under the <code>examples</code> folder in the repo and call it <code>my-deployment</code>.</p> Bash<pre><code>$ cd examples &amp;&amp; mkdir my-deployment &amp;&amp; cd my-deployment\n</code></pre> <p>We need a Container Network Interface (CNI) plug-in in order to run applications on the Kubernetes cluster. Luckily, there already is a deployment of the <code>flannel</code> CNI plug-in under the <code>examples</code> folder. Let's copy the contents under that folder to customize our deployment.</p> Bash<pre><code>$ cp ../cluster-with-cni/* .\n</code></pre> <p>Now we need to assign the variables used in the <code>module</code> block located in the file <code>main.tf</code> from the previous step with attributes it needs to run. There are multiple ways to accomplish that. For demonstration, we'll populate the <code>terraform.tfvars</code> file with the variable assignments. For more info on <code>terraform.tfvars</code>, see <code>Assign values with a file</code> documentation. For other options, see <code>Customize Terraform configuration with variables</code></p> <p>Remember to assign the <code>metal_auth_token</code> and the <code>metal_project_id</code> variables with the values obtained from Part 1 of the workshop.</p> Bash<pre><code>$ mv terraform.tfvars.example terraform.tfvars\n</code></pre> Terraform<pre><code># This must be a user API token\nmetal_auth_token        = \"pUqwuRtmQ3cMZBKodr1arir5GejbFNsp\"\nmetal_project_id        = \"16a060ea-9de3-4cd1-3601-49d38495d426\"\n# Optional, where you want to store your SSH key\nkube_vip_version        = \"v0.6.2\"\nkubernetes_version      = \"v1.28.1\"\nmetal_metro             = \"da\"\n# Optional, choose a specific flannel version, default is v0.24.2\n# flannel_version      = \"v0.24.2\"\n# Optional, name of a specific cloud provider. Possible values: external, YOUR_CLOUD_PROVIDER, \"\" (empty for internal cloud controller)\ncloud_provider_external = false\n</code></pre> <p>Note: You may build custom documentation in README.md but it does not necessarily need to be populated in order to provision infrastructure.</p>"},{"location":"parts/part2/#3-install-the-kubernetes-command-line-tool-kubectl","title":"3. Install the Kubernetes Command Line Tool: kubectl","text":"<p>There are many tools available to manage a Kubernetes cluster. For demonstration, we will focus on <code>kubectl</code> as our Kubernetes CLI manager of choice.</p> <p>To install <code>kubectl</code> on MacOS, please follow these instructions.</p> <p>We are ready to run Terraform to provision the kubernetes cluster!</p>"},{"location":"parts/part2/#4-provision-kubernetes","title":"4. Provision Kubernetes","text":"<p>Now that we have finished building the terraform plan, we need to apply it. Let's take the same steps demonstrated in <code>Part 3: Apply a Terraform Plan</code> of the the <code>Terraform on Equinix</code> workshop.</p> Bash<pre><code>$ terraform init --upgrade\n$ terraform plan\n$ terraform apply -auto-approve\n</code></pre> <p>Once the terraform apply execution ends, you will see something like this:</p> Terraform<pre><code>Apply complete! Resources: 17 added, 0 changed, 0 destroyed.\n\nOutputs:\n\ntfk8s_outputs = {\n  \"cloud_init_done\" = \"3049598830591298943\"\n  \"kubeconfig_ready\" = \"6387064462670964962\"\n  \"kubeip_vip\" = \"86.109.9.237\"\n}\n</code></pre>"},{"location":"parts/part2/#5-configure-the-kubernetes-command-line-tool-kubectl","title":"5. Configure the Kubernetes Command Line Tool: kubectl","text":"<p><code>kubectl</code> sets the default config file path to <code>$HOME/.kube/config</code>. We will populate this config file with the contents of the file <code>kubeconfig.admin.yaml</code> file generate at the root of the workspace folder <code>my-deployment</code> from the previous Step 3.</p> Bash<pre><code>$ cat kubeconfig.admin.yaml &gt; $HOME/.kube/config\n</code></pre> <p>Alternatively, you could reference the generated config file <code>kubeconfig.admin.yaml</code> directly to manage the cluster. For instance:</p> Bash<pre><code>$ kubectl --kubeconfig kubeconfig.admin.yaml get svc\nNAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE\nkubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP   68m\n</code></pre> <p>Now that you have configured <code>kubectl</code>, let's verify its configuration:</p> Bash<pre><code>$ kubectl config view\napiVersion: v1\nclusters:\n- cluster:\n    certificate-authority-data: DATA+OMITTED\n    server: https://86.109.9.237:6443\n  name: kubernetes\ncontexts:\n- context:\n    cluster: kubernetes\n    user: kubernetes-admin\n  name: kubernetes-admin@kubernetes\ncurrent-context: kubernetes-admin@kubernetes\nkind: Config\npreferences: {}\nusers:\n- name: kubernetes-admin\n  user:\n    client-certificate-data: DATA+OMITTED\n    client-key-data: DATA+OMITTED\n</code></pre> <p>Note that the cluster server IP <code>86.109.9.237</code> matches the <code>kubeip_vip</code> output posted in the outputs of the terraform run completed in Step 3.</p>"},{"location":"parts/part2/#discussion","title":"Discussion","text":"<p>Before proceeding to the next part let's take a few minutes to discuss what we did. Here are some questions to start the discussion.</p> <ul> <li>How many ways can a Kubernetes cluster be managed?</li> </ul>"},{"location":"parts/part3/","title":"3. Deploying a Demo App","text":""},{"location":"parts/part3/#part-3-deploying-a-demo-app","title":"Part 3: Deploying a Demo App","text":"<p>We have a Kubernetes Cluster up and running. Let's deploy a small sample app into the cluster provisioned in Part 2 of the workshop. The following steps require that you have a basic understanding of how to run applications on Kubernetes. For further info, please read <code>Run Applications</code> Kubernetes Documentation.</p> <p>The steps below will guide you to deploy a sample app onto a Kubernetes cluster.</p>"},{"location":"parts/part3/#steps","title":"Steps","text":""},{"location":"parts/part3/#1-clone-the-kubernetes-examples-repo","title":"1. Clone the Kubernetes examples repo","text":"<p>In order to deploy an app into Kubernetes, we are going to need the app's deployment manifest files. For demonstration, we are going to clone the example-voting-app</p> Bash<pre><code>$ git clone https://github.com/dockersamples/example-voting-app.git\n</code></pre>"},{"location":"parts/part3/#2-deploy-the-sample-app","title":"2. Deploy the sample app","text":"<p>For demonstation, we are going to the deploy the <code>example-voting-app</code>. This solution uses Python, Node.js, .NET, with Redis for messaging and Postgres for storage</p> <p>Let's deploy the app onto Kubernetes:</p> Bash<pre><code>$ cd example-voting-app\n$ kubectl create -f k8s-specifications/\nservice/db created\ndeployment.apps/redis created\nservice/redis created\ndeployment.apps/result created\nservice/result created\ndeployment.apps/vote created\nservice/vote created\ndeployment.apps/worker created\n</code></pre>"},{"location":"parts/part3/#3-verify-the-deployment","title":"3. Verify the deployment","text":"<p>Now that we have deployed the sample, let's access the frontend of the <code>vote</code> and <code>result</code> services.</p> Bash<pre><code>$ kubectl get services\nNAME         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE\ndb           ClusterIP   10.106.128.127   &lt;none&gt;        5432/TCP         15m\nkubernetes   ClusterIP   10.96.0.1        &lt;none&gt;        443/TCP          56m\nredis        ClusterIP   10.100.238.46    &lt;none&gt;        6379/TCP         15m\nresult       NodePort    10.108.141.185   &lt;none&gt;        5001:31001/TCP   15m\nvote         NodePort    10.102.54.144    &lt;none&gt;        5000:31000/TCP   15m\n</code></pre> <p>The <code>result</code> service is exposed on port <code>31001</code> and the <code>vote</code> service is exposed on port <code>31000</code> from the service definition shown above. Since we know that the cluster IP is <code>86.109.9.237</code> from Part 2, let's insert <code>http://86.109.9.237:31000/</code> into a Web browser to check out the <code>vote</code> Web interface and <code>http://86.109.9.237:31001/</code> to check out the <code>result</code> Web interface of the sample app.</p> <p>On <code>http://86.109.9.237:31000/</code> URL, we should see: </p> <p>Click on the <code>Cats</code> button to cast a vote for cats.</p> <p>On <code>http://86.109.9.237:31001/</code> URL, we should see: </p>"},{"location":"parts/part3/#discussion","title":"Discussion","text":"<p>Let's take a few minutes to discuss what we did. Here are some questions to start the discussion.</p> <ul> <li>How is an application deployed on a Kubernetes cluster?</li> <li>How do we verify that the application services are running ok on a Kubernetes cluster?</li> </ul>"}]}